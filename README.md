C Compiler in C#
===

This intends to be a full ANSI C compiler. It generates x86 (32-bit) assembly code in linux. The goal is to produce `.s` files that `gcc`'s assembler and linker could directly use.

### 1. Handwritten Scanner (lexical analysis) - done
* Not automatically generated by flex.
* Written via standard state-machine approach.

The first phase of a compiler is lexical analysis. In this phase, the source code is loaded and scanned through, to produce a list of minimial grammar units - tokens. Tokens are to programming languages just as words are to English. Each token in the C language falls into one of these categories: char, float, identifier, int, keyword, operator, and string.

You might see different classification methods, such as one that has the punctuator, which I group into the operator type.

Let's look at a concrete example. Suppose we have a line of code that looks like this.

```C
int a = ceil(3.2);
```

After lexical analysis, the code will be tranformed into these tokens:

* "int": keyword(int)
* "a": identifier("a")
* "=": operator(assignment)
* "ceil": identifier("ceil")
* "(": operator(open parenthesis)
* "3.2": float(3.2, no suffix, indicating that it is a double)
* ")": operator(close parenthesis)

Note that each token has a type, and some type-specific data: for a keyword, you need to know exactly which keyword it is; for a floating number, you need to know what number it is, and whether it's a float or a double; etc.

Each kind of token has its unique pattern, making it recognizable by the program. For example, an identifier always starts with an underscore '_' or a letter, so we won't confuse it with an integer.

### 2. Handwritten Parser (grammar analysis) - done
* Not automatically generated by yacc / bison.
* Standard recursive descent parser, with a little hack.

### 3. Semantic Analysis - done
* A type system to perform the C language implicit typecasts and other tasks.
* An environment system to record the user defined symbols.

### 4. Code Generator - round 20%
* Generates x86 assembly code.

### About environment change in expressions
I thought that the environment shouldn't change (no new type or object introduced inside an expression). That now seems not correct.

Consider this:

```C
int size = sizeof(struct A { int a; });
// a new type introduced insize a 'sizeof' expression.

void *ptr = (struct B { int b; } *)0x0;
// a new type introduced insize a type-cast expression.

struct A a = { 3 };
struct B b = { 4 };
// these new types can also be referred to afterwards, but only in the same scope.
```