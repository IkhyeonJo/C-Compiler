C Compiler in C#
===

This intends to be a full ANSI C compiler. It generates x86 (32-bit) assembly code in linux. The goal is to produce `.s` files that `gcc`'s assembler and linker could directly use.

### 1. Handwritten Scanner (lexical analysis) - done
* Not automatically generated by flex.
* Written via standard state-machine approach.

The first phase of a compiler is lexical analysis. In this phase, the source code is loaded and scanned through, to produce a list of minimial grammar units - tokens. Tokens are to programming languages just as words are to English. Each token in the C language falls into one of these categories: char, float, identifier, int, keyword, operator, and string.

You might see different classification methods, such as one that has the punctuator, which I group into the operator type.

Let's look at a concrete example. Suppose we have a line of code that looks like this.

```C
int a = ceil(3.2);
```

After lexical analysis, the code will be tranformed into these tokens:

| Source | Token kind | Data |
|:------:|:----------:|:----:|
| `int`  | Keyword    | int  |
| `a`    | Identifier | `"a"` |
| `=`    | Operator   | assignment |
| `ceil` | Identifier | `"ceil"` |
| `(`    | Operator   | open parenthesis |
| `3.2`  | Float      | 3.2, no suffix, indicating that is a double |
| `)`    | Operator   | close parenthesis |
| `;`    | Operator   | semicolon |

Note that each token has a type, and some type-specific data: for a keyword, you need to know exactly which keyword it is; for a floating number, you need to know what number it is, and whether it's a float or a double; etc.

Each kind of token has its unique pattern, making it recognizable by the program. For example, an identifier always starts with an underscore '_' or a letter, so we won't confuse it with an integer.

### 2. Handwritten Parser (grammar analysis) - done
* Not automatically generated by yacc / bison.
* Standard recursive descent parser, with a little hack.

### 3. Semantic Analysis - done
* A type system to perform the C language implicit typecasts and other tasks.
* An environment system to record the user defined symbols.

### Environment
To determine the semantics of a piece of code, we must examine it in the context.

Take the following two pieces of code as an example.

Code snippet 1:
```C
int a = 3;
int b = 4;
a * b;
```

Code snippet 2:
```C
typedef int a;
a *b;
```

Both have a line `a * b;`, but they mean very different things. The first is a multiplication expression (though performing the multplication doesn't seem to do any good...), while the second is a declaration of a variable b.

It turns out that the environment only has an impact on **identifiers** - we can't conclude what a given identifier refers to, until we're given an environment. So we need to maintain a data structure to record all user-defined identifiers.

So, where could a new identifier come in?

1. Declaration statements.

    Obviously, the purpose of a declaration is just to introduce a new identifier. 

### 4. Code Generator - round 20%
* Generates x86 assembly code.

### About environment change in expressions
I thought that the environment shouldn't change (no new type or object introduced inside an expression). That now seems not correct.

Consider this:

```C
int size = sizeof(struct A { int a; });
// a new type introduced insize a 'sizeof' expression.

void *ptr = (struct B { int b; } *)0x0;
// a new type introduced insize a type-cast expression.

struct A a = { 3 };
struct B b = { 4 };
// these new types can also be referred to afterwards, but only in the same scope.
```